#!/usr/bin/env python3
"""
Script de verifica√ß√£o de sa√∫de do sistema MVP CGU.
Verifica conex√µes, depend√™ncias e estado geral da aplica√ß√£o.
"""

import sys
import logging
import time
from pathlib import Path

# Adiciona o diret√≥rio app ao path para importar m√≥dulos
sys.path.append(str(Path(__file__).resolve().parent.parent / "app"))

try:
    from config import settings, setup_logging, validate_environment, get_data_paths
    from qdrant_client import QdrantClient
    from sentence_transformers import SentenceTransformer
    import pandas as pd
    import pickle
    import requests
except ImportError as e:
    print(f"‚ùå Erro ao importar depend√™ncias: {e}")
    sys.exit(1)

# Configura logging
setup_logging()
logger = logging.getLogger(__name__)

class HealthChecker:
    def __init__(self):
        self.results = []
        self.critical_failures = 0
        self.warnings = 0
        
    def check(self, name: str, func, critical: bool = True):
        """Executa uma verifica√ß√£o e registra o resultado."""
        try:
            start_time = time.time()
            result = func()
            duration = time.time() - start_time
            
            if result:
                status = "‚úÖ PASS"
                logger.info(f"{status} {name} ({duration:.2f}s)")
            else:
                status = "‚ùå FAIL" if critical else "‚ö†Ô∏è WARN"
                logger.error(f"{status} {name}")
                if critical:
                    self.critical_failures += 1
                else:
                    self.warnings += 1
            
            self.results.append({
                "name": name,
                "status": "PASS" if result else ("FAIL" if critical else "WARN"),
                "duration": duration,
                "critical": critical
            })
            
        except Exception as e:
            status = "üí• ERROR"
            logger.error(f"{status} {name}: {e}")
            if critical:
                self.critical_failures += 1
            else:
                self.warnings += 1
                
            self.results.append({
                "name": name,
                "status": "ERROR",
                "duration": 0,
                "critical": critical,
                "error": str(e)
            })
    
    def check_environment_variables(self) -> bool:
        """Verifica vari√°veis de ambiente essenciais."""
        try:
            # Testa a configura√ß√£o
            _ = settings.model_name
            _ = settings.qdrant_host
            _ = settings.qdrant_port
            return True
        except Exception as e:
            logger.error(f"Erro nas configura√ß√µes: {e}")
            return False
    
    def check_data_files(self) -> bool:
        """Verifica se os arquivos de dados existem."""
        paths = get_data_paths()
        
        required_files = [
            paths["recursos_parquet"],
            paths["pedidos_parquet"],
        ]
        
        all_exist = True
        for file_path in required_files:
            if not file_path.exists():
                logger.error(f"Arquivo n√£o encontrado: {file_path}")
                all_exist = False
            else:
                # Testa se pode ler o arquivo
                try:
                    df = pd.read_parquet(file_path, nrows=1)
                    logger.debug(f"Arquivo v√°lido: {file_path}")
                except Exception as e:
                    logger.error(f"Erro ao ler {file_path}: {e}")
                    all_exist = False
        
        return all_exist
    
    def check_vector_files(self) -> bool:
        """Verifica se os arquivos de vetores existem."""
        paths = get_data_paths()
        vetores_dir = paths["vetores_dir"]
        
        if not vetores_dir.exists():
            logger.error(f"Diret√≥rio de vetores n√£o encontrado: {vetores_dir}")
            return False
        
        # Procura por arquivos .pkl
        pickle_files = list(vetores_dir.glob("*.pkl"))
        
        if len(pickle_files) < 2:
            logger.error(f"Poucos arquivos de vetores encontrados: {len(pickle_files)}")
            return False
        
        # Testa um arquivo
        for pkl_file in pickle_files[:1]:
            try:
                with open(pkl_file, 'rb') as f:
                    data = pickle.load(f)
                    if 'embeddings' not in data:
                        logger.error(f"Arquivo {pkl_file} n√£o cont√©m 'embeddings'")
                        return False
                    logger.debug(f"Arquivo de vetores v√°lido: {pkl_file}")
            except Exception as e:
                logger.error(f"Erro ao ler {pkl_file}: {e}")
                return False
        
        return True
    
    def check_qdrant_connection(self) -> bool:
        """Verifica conex√£o com Qdrant."""
        try:
            client = QdrantClient(
                host=settings.qdrant_host,
                port=settings.qdrant_port,
                timeout=10
            )
            
            # Testa conex√£o b√°sica
            collections = client.get_collections()
            logger.debug(f"Qdrant conectado. Cole√ß√µes: {len(collections.collections)}")
            
            return True
        except Exception as e:
            logger.error(f"Erro ao conectar com Qdrant: {e}")
            return False
    
    def check_qdrant_collections(self) -> bool:
        """Verifica se as cole√ß√µes necess√°rias existem no Qdrant."""
        try:
            client = QdrantClient(
                host=settings.qdrant_host,
                port=settings.qdrant_port,
                timeout=10
            )
            
            required_collections = [
                settings.qdrant_recursos_collection,
                settings.qdrant_pedidos_collection
            ]
            
            for collection_name in required_collections:
                if not client.collection_exists(collection_name):
                    logger.error(f"Cole√ß√£o n√£o existe: {collection_name}")
                    return False
                    
                info = client.get_collection(collection_name)
                if info.points_count == 0:
                    logger.warning(f"Cole√ß√£o {collection_name} est√° vazia")
                else:
                    logger.debug(f"Cole√ß√£o {collection_name}: {info.points_count} pontos")
            
            return True
        except Exception as e:
            logger.error(f"Erro ao verificar cole√ß√µes: {e}")
            return False
    
    def check_embedding_model(self) -> bool:
        """Verifica se o modelo de embedding pode ser carregado."""
        try:
            # Tenta carregar o modelo (pode ser lento na primeira vez)
            model = SentenceTransformer(settings.model_name)
            
            # Testa uma embedding simples
            test_text = "Este √© um teste de embedding."
            embedding = model.encode(test_text)
            
            if len(embedding) > 0:
                logger.debug(f"Modelo carregado. Dimens√£o do embedding: {len(embedding)}")
                return True
            else:
                logger.error("Embedding vazio gerado")
                return False
                
        except Exception as e:
            logger.error(f"Erro ao carregar modelo de embedding: {e}")
            return False
    
    def check_groq_api(self) -> bool:
        """Verifica se a API do Groq est√° acess√≠vel."""
        if not settings.groq_api_key:
            logger.info("API Groq n√£o configurada (opcional)")
            return True
        
        try:
            from groq import Groq
            client = Groq(api_key=settings.groq_api_key)
            
            # Teste simples
            response = client.chat.completions.create(
                model=settings.groq_model,
                messages=[{"role": "user", "content": "test"}],
                max_tokens=5
            )
            
            if response.choices:
                logger.debug("API Groq funcionando")
                return True
            else:
                logger.error("Resposta vazia da API Groq")
                return False
                
        except Exception as e:
            logger.error(f"Erro ao testar API Groq: {e}")
            return False
    
    def check_fastapi_dependencies(self) -> bool:
        """Verifica se as depend√™ncias do FastAPI est√£o dispon√≠veis."""
        try:
            import fastapi
            import uvicorn
            import pydantic
            logger.debug("Depend√™ncias do FastAPI OK")
            return True
        except ImportError as e:
            logger.error(f"Depend√™ncia faltando: {e}")
            return False
    
    def run_all_checks(self):
        """Executa todas as verifica√ß√µes."""
        logger.info("üîç Iniciando verifica√ß√µes de sa√∫de do sistema...")
        
        # Verifica√ß√µes cr√≠ticas
        self.check("Vari√°veis de ambiente", self.check_environment_variables, critical=True)
        self.check("Depend√™ncias FastAPI", self.check_fastapi_dependencies, critical=True)
        self.check("Arquivos de dados", self.check_data_files, critical=True)
        self.check("Conex√£o Qdrant", self.check_qdrant_connection, critical=True)
        self.check("Cole√ß√µes Qdrant", self.check_qdrant_collections, critical=True)
        
        # Verifica√ß√µes importantes mas n√£o cr√≠ticas
        self.check("Arquivos de vetores", self.check_vector_files, critical=False)
        self.check("Modelo de embedding", self.check_embedding_model, critical=False)
        self.check("API Groq", self.check_groq_api, critical=False)
        
        # Relat√≥rio final
        self.print_summary()
        
        return self.critical_failures == 0
    
    def print_summary(self):
        """Imprime um resumo dos resultados."""
        total_checks = len(self.results)
        passed = sum(1 for r in self.results if r["status"] == "PASS")
        failed = sum(1 for r in self.results if r["status"] == "FAIL")
        errors = sum(1 for r in self.results if r["status"] == "ERROR")
        warnings = sum(1 for r in self.results if r["status"] == "WARN")
        
        print("\n" + "="*50)
        print("üìã RESUMO DAS VERIFICA√á√ïES")
        print("="*50)
        print(f"‚úÖ Passou: {passed}")
        print(f"‚ùå Falhou: {failed}")
        print(f"üí• Erro: {errors}")
        print(f"‚ö†Ô∏è Aviso: {warnings}")
        print(f"üìä Total: {total_checks}")
        
        if self.critical_failures == 0:
            print("\nüéâ Sistema est√° saud√°vel e pronto para uso!")
        else:
            print(f"\n‚ö†Ô∏è {self.critical_failures} falhas cr√≠ticas encontradas!")
            print("üîß Corrija os problemas antes de executar a aplica√ß√£o.")
        
        # Detalhes dos problemas
        problems = [r for r in self.results if r["status"] in ["FAIL", "ERROR"]]
        if problems:
            print("\nüîç PROBLEMAS ENCONTRADOS:")
            for problem in problems:
                status_icon = "üí•" if problem["status"] == "ERROR" else "‚ùå"
                print(f"{status_icon} {problem['name']}")
                if "error" in problem:
                    print(f"   ‚îî‚îÄ {problem['error']}")

def main():
    """Fun√ß√£o principal do health check."""
    print("üè• MVP CGU - Health Check")
    print(f"üìç Verificando sistema em: {Path.cwd()}")
    print()
    
    checker = HealthChecker()
    success = checker.run_all_checks()
    
    # Exit code baseado no resultado
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()